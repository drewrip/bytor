use std::str::FromStr;
use crate::ast::*;
use crate::types::*;
use crate::symbol::{Symbol, Var};

grammar;

pub Root: Box<Root> = {
    <pre_b:Stmts> <prog:Program> <post_b:Stmts> => Box::new(
        Root{preblock: pre_b, program: prog, postblock: post_b}
    ),
};

pub Stmts: Vec<Box<Stmt>> = {
    <v:(<Stmt>)*> => v,
}

pub Exprs = Comma<Expr>;
pub Args = Exprs;

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:(<T> ";")?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub IfCase: Box<IfCase> = {
    "if" <e:Expr> "then" <b:Stmts> => Box::new(IfCase {condition: e, block: b, is_else: false}),
};

pub ElseIfCase: Box<IfCase> = {
    "else" "if" <e:Expr> "then" <b:Stmts> => Box::new(IfCase {condition: e, block: b, is_else: false}),
};

pub ElseCase: Box<IfCase> = {
    "else" "then" <b:Stmts> => Box::new(IfCase {condition: Box::new(Expr::Term(Box::new(Term::Bool(true)))), block: b, is_else: true}),
};

pub Stmt: Box<Stmt> = {
    "let" <i:Id> "=" <e:Expr> ";" => Box::new(
        Stmt::Assign(
          Symbol{ident: i},
          Box::new(Var{type_t: Type::Unknown, node: Node::ExprNode(e.clone())}),
          e
        )
    ),
    "let" <i:Id> ":" <t:Type> "=" <e:Expr> ";" => Box::new(
        Stmt::Assign(
          Symbol{ident: i},
          Box::new(Var{type_t: t, node: Node::ExprNode(e.clone())}),
          e
        )
    ),
    <i:Id> <ao:AssignOp> <e:Expr> ";" => Box::new(
        Stmt::Reassign(
          Symbol{ident: i},
          Box::new(Var{type_t: Type::Unknown, node: Node::ExprNode(e.clone())}),
          ao,
          e
        )
    ),
    <ifcase:IfCase> <elseifcases:ElseIfCase*> <elsecase:ElseCase?> "end" => {
        let elsecases: Vec<Box<IfCase>> = match elsecase {
            Some(elsecasepresent) => vec![elsecasepresent],
            None => vec![],
        };
        Box::new(Stmt::If(vec![vec![ifcase], elseifcases, elsecases].concat()))
    },
    <id:Id> "(" <args:Args> ")" ";" => Box::new(Stmt::Call(Symbol{ident: id}, Box::new(args))),
    <f:Func> => Box::new(Stmt::FuncDef(f)),
    "return" <e:Expr> ";" => Box::new(Stmt::Return(e)),
};

pub Program: Box<Program> = {
    "program" <id:Id> <b:Stmts> "end" => Box::new(Program::NoWith(Symbol{ident: id}, b)),
    "program" <id:Id> <w:With> <b:Stmts> "end" => Box::new(Program::With(Symbol{ident: id}, w, b)),
};

pub With: With = {
    "with" "(" <w:WithVars> ")" => w,
};

pub WithVars = Comma<WithVar>;

pub WithVar: Box<WithVar> = {
    "mut" <id:Id> => Box::new(WithVar::Mut(Symbol{ident: id})),
    <id:Id> => Box::new(WithVar::Imm(Symbol{ident: id})),
};

pub Params: Params = Comma<Param>;

pub Param: Box<Param> = {
    <id:Id> ":" <t:Type> => Box::new(Param{type_t: t, ident: id}),
};

pub Func: Box<Func> = {
    "function" <id:Id> "(" <p:Params> ")" <t:("->" <Type>)?> <w:With?> <b:Stmts> "end" => {
        let ret = match t {
            None => Type::Nil,
            Some(t) => t,
        };
        let with = match w {
            None => vec![],
            Some(w) => w,
        };
        Box::new(Func{ret_t: ret, params: p, with: with, ident: id, block: b})
    },
};

pub Expr: Box<Expr> = {
    #[precedence(level="0")] // Highest precedence
    <t:Term> => Box::new(Expr::Term(t)),
    <id:Id> "(" <args:Args> ")" => Box::new(Expr::Call(Symbol{ident: id}, Box::new(args))),
    #[precedence(level="1")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Box::new(Expr::Mult(l, r)),
    <l:Expr> "/" <r:Expr> => Box::new(Expr::Div(l, r)),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Box::new(Expr::Add(l, r)),
    <l:Expr> "-" <r:Expr> => Box::new(Expr::Sub(l, r)),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => Box::new(Expr::Eq(l, r)),
    <l:Expr> "!=" <r:Expr> => Box::new(Expr::Neq(l, r)),
    <l:Expr> "<=" <r:Expr> => Box::new(Expr::Leq(l, r)),
    <l:Expr> ">=" <r:Expr> => Box::new(Expr::Geq(l, r)),
    <l:Expr> "<" <r:Expr> => Box::new(Expr::LessThan(l, r)),
    <l:Expr> ">" <r:Expr> => Box::new(Expr::GreaterThan(l, r)),
};

pub Term: Box<Term> = {
    <id:Id> => Box::new(Term::Id(id)),
    <n:Num> => Box::new(Term::Num(n)),
    <b:Bool> => Box::new(Term::Bool(b)),
    "(" <t:Expr> ")" => Box::new(Term::Expr(t)),
};

pub Bool: bool = {
    "true" => true,
    "false" => false,
}

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Id: String = r"([a-zA-Z_])([\w\d_])*" => String::from(<>);

pub AssignOp: AssignOp = {
    "=" => AssignOp::Assign,
    "+=" => AssignOp::AddAssign,
    "-=" => AssignOp::SubAssign,
    "*=" => AssignOp::MultAssign,
    "/=" => AssignOp::DivAssign,
};

pub Type: Type = {
    "int64" => Type::Int64,
    "int32" => Type::Int32,
    "uint64" => Type::UInt64,
    "uint32" => Type::UInt32,
    "float64" => Type::Float64,
    "float32" => Type::Float32,
    "bool" => Type::Bool,
    "Nil" => Type::Nil,
}
