use std::str::FromStr;
use std::sync::Arc;
use crate::ast::*;
use crate::types::*;
use crate::symbol::Var;

grammar;

pub Root: Arc<Root> = {
    <pre_b:Stmts> <prog:Program> <post_b:Stmts> => Arc::new(
        Root{preblock: pre_b, program: prog, postblock: post_b}
    ),
};

pub Stmts = Semicolon<Stmt>;
pub Exprs = Comma<Expr>;

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Stmt: Arc<Stmt> = {
    "let" <i:Id> "=" <e:Expr> => Arc::new(
        Stmt::Assign(Arc::new(Var{type_t: Type::Int64, name: i}), e)
    ),
    <i:Id> <ao:AssignOp> <e:Expr> => Arc::new(
        Stmt::Reassign(Arc::new(Var{type_t: Type::Int64, name: i}), ao, e)
    ),
    <id:Id> "(" <e:Exprs> ")" => Arc::new(Stmt::Call(id, e)),
    <f:Func> => Arc::new(Stmt::FuncDef(f)),
};

pub Program: Arc<Program> = {
    "program" <id:Id> <b:Stmts> "end" => Arc::new(Program::NoWith(id, b)),
    "program" <id:Id> <w:With> <b:Stmts> "end" => Arc::new(Program::With(id, w, b)),
};

pub With: With = {
    "with" "(" <w:WithVars> ")" => w,
};

pub WithVars = Comma<WithVar>;

pub WithVar: Arc<WithVar> = {
    "mut" <id:Id> => Arc::new(WithVar::Mut(id)),
    <id:Id> => Arc::new(WithVar::Imm(id)),
};

pub Params: Params = Comma<Param>;

pub Param: Arc<Var> = {
    <id:Id> ":" <t:Type> => Arc::new(Var{type_t: t, name: id}),
};

pub Func: Arc<Func> = {
    "function" <id:Id> "(" <p:Params> ")" <t:("->" <Type>)?> <w:With?> <b:Stmts> "end" => {
        let ret = match t {
            None => Type::Nil,
            Some(t) => Type::Int64,
        };
        let with = match w {
            None => vec![],
            Some(w) => w,
        };
        Arc::new(Func{ret_t: ret, params: p, with: with, ident: id, block: b})
    },
};

pub Expr: Arc<Expr> = {
    #[precedence(level="0")] // Highest precedence
    <t:Term> => Arc::new(Expr::Term(t)),
    <id:Id> "(" <e:Exprs> ")" => Arc::new(Expr::Call(id, e)),
    #[precedence(level="1")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Arc::new(Expr::Mult(l, r)),
    <l:Expr> "/" <r:Expr> => Arc::new(Expr::Div(l, r)),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Arc::new(Expr::Add(l, r)),
    <l:Expr> "-" <r:Expr> => Arc::new(Expr::Sub(l, r)),
};

pub Term: Arc<Term> = {
    <n:Num> => Arc::new(Term::Num(n)),
    "(" <t:Expr> ")" => Arc::new(Term::Expr(t)),
};

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Id: String = r"([a-zA-Z_])([\w\d_])*" => String::from(<>);

pub AssignOp: AssignOp = {
    "=" => AssignOp::Assign,
    "+=" => AssignOp::AddAssign,
    "-=" => AssignOp::SubAssign,
    "*=" => AssignOp::MultAssign,
    "/=" => AssignOp::DivAssign,
};

pub Type: Type = {
    "int64" => Type::Int64,
    "int32" => Type::Int32,
    "uint64" => Type::UInt64,
    "uint32" => Type::UInt32,
    "float64" => Type::Float64,
    "float32" => Type::Float32,
    "Nil" => Type::Nil,
}
